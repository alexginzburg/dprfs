#!/usr/bin/env python

import os
import sys
import socket
import select
import struct
import json
import time
import uuid
import ConfigParser
import binascii
import hashlib

#from lib.client import dprf_open
#from lib.client import dprf_read
#from lib.client import dprf_write

message = {
	'filename':	None,
	'id':		None,
	'r':		None,
	'h':		None,
	'cmd':		None,
}

config = ConfigParser.ConfigParser()
config.read( 'client.conf' )

network_address	= config.get( 'client', 'network_address' )
network_port	= config.getint( 'client', 'network_port' )
status_timeout	= config.getfloat( 'client', 'status_timeout' )
data_timeout	= config.getfloat( 'client', 'data_timeout' )
buffer_size	= config.getint( 'client', 'buffer_size' )


def dprfs_open( s, filename ):

	id = uuid.uuid4().hex
	
	message = {
		'id':	id,
		'cmd':	'open',
		'fn':	filename,
	}
	msg = {
		'id':	id,
		'fn':	filename,
		'h':	[],
		'r':	{
		   'base':	None,
		   'top':	None, 
		}
	}

	print "=== %s msg_out='%s'" % ( __name__, message )
	sent = s.sendto( json.dumps(message), ( network_address, network_port ) )
	s.settimeout( status_timeout )
	start = time.time()

	while True:
		try:
			msg_in, sender_addr = s.recvfrom( buffer_size * 2 )
			msg_in = json.loads(msg_in)
			if msg['id'] == msg_in['id']:
				msg['id'] = msg_in['id']
				msg['fn'] = msg_in['r']['fn']
				if msg['r']['top'] is None:
					msg['r']['base'] = msg_in['r']['base']
					msg['r']['top'] = msg_in['r']['top']
				if msg['r']['top'] == msg_in['r']['top']:
					#host = msg['h']
					#host.append( msg_in['h'] )
					msg['h'] = msg_in['h']
				
			
		except socket.timeout, ex:
			print >> sys.stderr, "socket.timeout %s" % ex
			s.settimeout( 0 )
			break
	print "=== %s msg='%s'" % ( __name__, msg )

	return json.dumps(msg)

def dprfs_read ( s, fd ):

	fn = fd.get('fn', None)
	if not fn:
		fn = fd['r'].get('fn', None)

	host = fd['h'][0]
	port = fd['h'][1]

	fd = {
		'id':	uuid.uuid4().hex,
		'cmd':	'read',
		'h':	( host, port ),
		'r':	{
		  'next':	fd['r']['next'],
		  'fn':		fn,
		}
	}

	print >> sys.stderr, "=== %s out='%s'" % ( __name__, json.dumps(fd) )

	s.settimeout( data_timeout )

	s.sendto( json.dumps(fd), ( host, port ) )

	start = time.time()
	try:
		msg_in, sender_addr = s.recvfrom( buffer_size * 2 )
		s.settimeout( 0 )
	except socket.timeout, ex:
		print >> sys.stderr, "=== socket.timeout '%s'" % ex
		return None
	
	return json.loads(msg_in)

def dprf_write ( s, fd, sys_fd ):


	host = fd['h'][0]
	port = fd['h'][1]

	previous = None
	top = None

	while top is None:
		r = sys_fd.read( buffer_size )
		if r == '':
			top = previous

		r = binascii.b2a_base64( r )

		p = {
			'id':	uuid.uuid4().hex,
			'cmd':	'write',
			'fn':	fd['fn'],
			'r':	{
				'data': r,
				'prev': previous,
				'top':	top,
			},
		}

		s.settimeout( data_timeout )
		s.sendto( json.dumps(p), ( host, port ) )

		start = time.time()
		try:
			msg_in, sender_addr = s.recvfrom( buffer_size )
			s.settimeout( 0 )
			msg_in = json.loads( msg_in )
			if previous == msg_in['r']['base']:
				print >> sys.stderr, "=== %s loop? %s" % ( __name__, previous )
				return None
			previous = msg_in['r']['base']
		except socket.timeout, ex:
			print >> sys.stderr, "=== socket.timeout '%s'" % ex
			return None
	

command = {
        'open':         dprfs_open,
        'read':         dprfs_read,
}

filename = sys.argv[1]

s = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )

ttl = struct.pack( 'b', 1 )
s.setsockopt( socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl )

result = dprfs_open(s, filename)
result = json.loads(result)

fp = open( filename, "rb")
dprf_write( s, result, fp )
fp.close()

result = dprfs_open(s, filename)
result = json.loads(result)

rf = open( "foo.pdf", "wb" )
result['r']['next'] = result['r']['base']
while True:
	result = dprfs_read( s, result )
	chunk = binascii.a2b_base64( result['r']['data'] )
	current = hashlib.sha1(chunk).hexdigest()
	rf.write( chunk )
	if result['r']['top'] == current:
		break
	if result['r']['next'] is None:
		break

rf.close()
s.close()
sys.exit(0)

