#!/usr/bin/env python

import os
import sys
import socket
import select
import struct
import json
import hashlib
import ConfigParser
import xattr
import binascii

config = ConfigParser.ConfigParser()
config.read( 'server.conf' )

buffer_size	= config.getint( 'general', 'buffer_size' )

network_group 	= config.get( 'status', 'network_group' )
network_port 	= config.getint( 'status', 'network_port' )
meta_root	= config.get( 'status', 'meta_root' )

data_address	= config.get( 'data', 'network_address' )
data_port	= config.getint( 'data', 'network_port' )
data_root	= config.get( 'data', 'data_root' )

def _ls( ):
	return {}

def _open( fd ):

	filename = fd['fn']
	r = None

	try:
		os.chdir(os.path.join(meta_root, filename))
		r = {
			'base': os.readlink('base'),
			'top':	os.readlink('top'),
			'fn':	filename,
		}
	except Exception, ex:
		r = {
			'id':	None,
			'fn':	filename,
		}
	return r

def _read( fd ):
	request = fd['r']['next']
	filename = fd['r']['fn']

	base = os.path.join(
		meta_root,
		filename,
		'base'
	)
	c = {
		'base': os.readlink('base'),
		'top':	os.readlink('top'),
		'data':	None,
		'next':	None,
		'fn':	fd['r']['fn'],
	} 

	if request is None:
		return c
	
	filename = os.path.join( data_root, request[:4], request ) 
	df = open(filename, "rb")
	data = []
	chunk = df.read( buffer_size * 2 )
	c['data'] = binascii.b2a_base64( chunk )
	try:
		c['next'] = xattr.getxattr(df, 'dprfs.next')
	except KeyError, ex:
		c['next'] = None

	finally:
		df.close()

	return c

def _write( fd ):

# meta_root/<file_name>/{base,top}
# the data chunk has an attribute with
#	previous
#   and next
# data chunk hashes

	chunk = binascii.a2b_base64( fd['r']['data'] )
	try:
		previous = fd['r']['prev']
	except KeyError, ex:
		previous = 'none'

	top = fd['r']['top']

	filename = fd['fn']

	path = "%s/%s" % ( meta_root, filename )
	try:
	  os.mkdir(path)
	except os.error, ex:
	  pass

	if top:
		link_name = os.path.join( path, 'top' )
		try:
			os.symlink(
				top,
				link_name
			)
		except os.error, ex:
			pass

		return {
			'base': top,
			'fn':	fd['fn'],
		}

	current = hashlib.sha1(chunk).hexdigest()
	dirname = os.path.join( data_root, current[:4] )
	try:
	  os.mkdir(dirname)
	except os.error, ex:
	  pass

	filename = os.path.join( dirname, current )
	df = open(filename, "wb")
	print >> df, chunk,
	df.close()
	if previous:
		xattr.setxattr( os.path.join(
				data_root,
				previous[:4],
				previous
			),
			'dprfs.next',
			current
		)
	
	link_name = os.path.join( path, 'base' )
	try:
		os.symlink( current, link_name )
	except os.error, ex:
		pass

	return {
		'base': current,
		'fn':	fd['fn'],
	}
	

def _stat( fd ):
	return {}

def _mv():
	pass

def _cp():
	pass

def _ln():
	pass

def _close():
	pass
	
command = {
	'open':		_open,
	'read':		_read,
	'write':	_write,
	'ls': 		_ls,
	'mv':		_mv,
	'cp':		_cp,
	'ln':		_ln,
	'stat':		_stat,
}

s = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
s.bind( ('', network_port) )
group = socket.inet_aton( network_group )
mreq = struct.pack( '4sL', group, socket.INADDR_ANY )
s.setsockopt( socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq )

ds = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
ds.setsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR, 1 )
ds.bind( ( data_address, network_port) )

while 1:
	p = {
	  'id':	None,
	  'h':	None,
	  'cmd': None,
	  'r':	None,
	}

	read_fd, _, _ = select.select( [ s, ds ], [], [] )
	msg_in = {}
	msg_in, remote_addr = read_fd[0].recvfrom( 4096 * 8 )

	msg_in = json.loads( msg_in )

	p = {
		'id':	msg_in['id'],
		'cmd':	msg_in['cmd'],
		'h':	(data_address, data_port),
	}

	p['r'] = command[p['cmd']](msg_in)

	s.sendto( json.dumps( p ), remote_addr )

s.close()
sys.exit(0)
